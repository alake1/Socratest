[{"question": "What is the primary purpose of the `useEffect` hook in React?", "options": ["To render components conditionally based on state changes.", "To manage side effects, such as data fetching or DOM manipulation.", "To define reusable components that can be used throughout the application.", "To handle user input and update the component's state."], "correctOption": 1, "explanation": "The `useEffect` hook is used to perform side effects, which are actions that interact with the outside world, such as fetching data, setting up subscriptions, or interacting with the DOM."}, {"question": "Which of the following statements about `useState` is **incorrect**?", "options": ["It allows you to manage the state of a component.", "It returns an array containing the current state and a function to update it.", "It automatically re-renders the component whenever the state changes.", "It can only be used within functional components."], "correctOption": 3, "explanation": "The `useState` hook can be used in both functional and class-based components. It is a fundamental hook for managing component state in React."}, {"question": "What is the purpose of the `key` prop in React's list rendering?", "options": ["To uniquely identify each element in the list for efficient rendering.", "To specify the order in which elements should be rendered.", "To provide a user-friendly label for each list item.", "To define the data type of each element in the list."], "correctOption": 0, "explanation": "The `key` prop helps React efficiently update the list when its data changes. By providing a unique identifier for each element, React can determine which elements have been added, removed, or modified, leading to optimized re-rendering."}, {"question": "Which of the following is **not** a valid way to pass data to a child component in React?", "options": ["Using props.", "Using the `context` API.", "Using global variables.", "Using a ref."], "correctOption": 2, "explanation": "While global variables can be accessed from anywhere in the application, they are generally discouraged for passing data between components due to potential side effects and difficulty in managing dependencies. Props, context, and refs are preferred methods for data sharing."}, {"question": "What is the primary difference between the `useCallback` and `useMemo` hooks?", "options": ["`useCallback` memoizes functions, while `useMemo` memoizes values.", "`useCallback` prevents unnecessary re-renders, while `useMemo` optimizes expensive computations.", "`useCallback` is used for state management, while `useMemo` is used for data fetching.", "`useCallback` is only applicable to functional components, while `useMemo` works with both functional and class-based components."], "correctOption": 0, "explanation": "`useCallback` memoizes functions, preventing them from being recreated unnecessarily. `useMemo` memoizes the result of expensive computations, allowing React to reuse the cached value instead of re-computing it every time."}, {"question": "How does React handle asynchronous operations, like fetching data, without blocking the main thread?", "options": ["By using a separate thread for asynchronous tasks.", "By using promises or async/await to handle asynchronous operations.", "By pausing the rendering process until the asynchronous operation completes.", "By using a dedicated event loop for asynchronous tasks."], "correctOption": 1, "explanation": "React relies on JavaScript's built-in features, such as promises and async/await, to handle asynchronous operations without blocking the main thread. This allows the user interface to remain responsive while asynchronous tasks are in progress."}, {"question": "What is the purpose of the `ref` attribute in React?", "options": ["To define the data type of a component's state.", "To provide a unique identifier for a component.", "To create a reference to a DOM element, allowing direct access and manipulation.", "To define the initial value of a component's state."], "correctOption": 2, "explanation": "Refs provide a way to access a DOM element directly from a React component, enabling tasks like focusing on an input field, measuring element dimensions, or triggering events."}, {"question": "Which of the following is a key principle of React's component lifecycle?", "options": ["Components are responsible for managing their own state and rendering.", "Components should be reusable and modular.", "Components should always be stateless and purely functional.", "Components are designed to be immutable and cannot be updated after creation."], "correctOption": 0, "explanation": "React's component lifecycle emphasizes the idea that components are self-contained units responsible for managing their own state and rendering logic. This promotes modularity and reusability."}, {"question": "What is the primary purpose of the `StrictMode` feature in React?", "options": ["To improve the performance of React applications by optimizing rendering.", "To enable server-side rendering for improved SEO and initial page load times.", "To identify potential issues and inconsistencies in components, such as deprecated APIs or unsafe practices.", "To provide a way to debug and troubleshoot React applications."], "correctOption": 2, "explanation": "React's `StrictMode` helps identify potential problems in components by simulating additional checks and warnings, promoting best practices and catching potential issues early in development."}, {"question": "What is the purpose of the `forwardRef` function in React?", "options": ["To create a function that can be passed as a prop to a child component.", "To pass a reference to a child component to its parent component.", "To create a reusable function that can be used throughout the application.", "To create a reference to a DOM element that can be accessed from a parent component."], "correctOption": 1, "explanation": "The `forwardRef` function is used to pass a ref created in a child component to its parent. This allows the parent component to access and interact with the child component's DOM elements."}, {"question": "Which of the following is a recommended way to manage state in a React application for complex scenarios?", "options": ["Using `useState` hook for every single piece of state", "Using a global state management library like Redux or Zustand", "Passing state down through props to child components", "Using local storage to store all application state"], "correctOption": 1, "explanation": "For complex applications with many interconnected components, state management libraries provide a more organized and efficient way to handle state updates and data flow."}, {"question": "What is the difference between `props` and `state` in React?", "options": ["Props are mutable, while state is immutable", "Props are passed down from parent components, while state is managed within the component itself", "Props are used for styling, while state is used for data", "Props are used for event handling, while state is used for rendering"], "correctOption": 1, "explanation": "Props are data passed from parent components, allowing for data sharing and component interaction. State is internal data managed within a component, representing its current status and enabling dynamic behavior."}, {"question": "How does React handle re-rendering of components?", "options": ["All components re-render every time any state changes in the application", "Components re-render only if their own state or props change", "Components re-render based on a predefined schedule", "Components re-render when the user interacts with them"], "correctOption": 1, "explanation": "React uses a virtual DOM to efficiently determine which components need to be re-rendered. It compares the previous state with the current state, and only updates the necessary components to minimize re-renders."}, {"question": "What is the purpose of the `context` API in React?", "options": ["To pass data down from parent components to child components", "To create reusable components", "To handle side effects within a component", "To share data globally without prop drilling"], "correctOption": 3, "explanation": "The `context` API allows data to be shared across components without the need to pass it through props at each level. This is particularly useful for providing global data or configurations throughout the application."}, {"question": "Which of the following is a best practice for handling errors in React?", "options": ["Using try-catch blocks within components", "Displaying a generic error message to the user", "Using error boundaries to catch and handle errors in components", "Ignoring errors and letting the application crash"], "correctOption": 2, "explanation": "Error boundaries are a recommended way to handle errors in React. They catch errors in their child components and provide a fallback UI to gracefully display error information to the user."}, {"question": "What is the difference between `setState` and `forceUpdate` in React?", "options": ["`setState` is synchronous, while `forceUpdate` is asynchronous", "`setState` triggers a re-render based on state changes, while `forceUpdate` forces a re-render regardless of state", "`setState` is used for updating state, while `forceUpdate` is used for handling events", "`setState` is used in functional components, while `forceUpdate` is used in class components"], "correctOption": 1, "explanation": "`setState` updates the component's state and triggers a re-render if the state changes. `forceUpdate` forces a re-render even if the state is unchanged, which is generally discouraged as it can lead to performance issues."}]